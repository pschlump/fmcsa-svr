package metrics

/*

CREATE TABLE if not exists t_key_value (
	id			uuid DEFAULT uuid_generate_v4() not null primary key,
	key			text not null,	-- the key.
	data		jsonb,			-- the data.
	updated 	timestamp, 									 						-- Project update timestamp (YYYYMMDDHHMMSS timestamp).
	created 	timestamp default current_timestamp not null 						-- Project creation timestamp (YYYYMMDDHHMMSS timestamp).
);
*/

// Create the storage system, call it "storeStats" -- Connect to Redis, Memory, Disk etc.
// Create the Metrics - pass it "storeStats"

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/pschlump/fmcsa-svr/status"
)

type MetricsData struct {
	Data map[string]int64
	prometheusCounter map[string]*prometheus.Desc
	Safe sync.Mutex
	SaveRateSeconds int
	store StorageSystem
}

func NewMetricsData ( saveMethod string, validKeys []string, desc []string, saveRateSeconds int, dataSaver StorageInterface  ) ( md *MetricsData ) {
	md = &MetricsData{
		Data: make(map[string]int64),
		SaveRateSeconds : saveRateSeconds,
	}
	for ii, kk := range validKeys {
		md.Data[kk] = 0
		md.prometheusCounter[kk] = prometheus.NewDesc( kk, desc[ii], nil, nil)
	}

	// create periodic timed data save.  If "memory" then no save

	// Call the storage "init" to pull data

	// Convert into md.Data
}

func AddMetricsKeys (  validKeys []string, desc []string ) {
	for ii, kk := range validKeys {
		md.Data[kk] = 0
		md.prometheusCounter[kk] = prometheus.NewDesc( kk, desc[ii], nil, nil)
	}
}

func (md *MetricsData)AddCounter ( CounterName string, int count ) ( err error ) {
	// Lock
	// Defer Unlock
	// Lookup - if not found then error - report to log
	// Pull out value
	// += count
	// Save
}

func (md *MetricsData)GetCounter ( CounterName string ) ( rv int64 ) {
	// ReadLock
	// Defer ReadUnlock
	// Lookup - if not found then error - report to log, return 0
	// Pull out value
	// Return it.
}



// TODO : Start-Time, End-Time (Duration)



func (md *MetricsData) Close() error {
	s := md.GetDataJson() // Flush  
	md.store.SaveData(s)
	return md.store.Close()
}

// Convert all of the data to JSON format and return as a string.  This is for periodic saves
func (md *MetricsData)GetDataJson () ( rv string ) {
	// ReadLock
	// defer ReadUnlock
	// convert to JSON
	// return
}

func (md *MetricsData)ResetCounters () {
	// Lock
	// Defer Unlock
	// Loop Over...
}


// Describe returns all possible prometheus.Desc
func (md * MetricsData) Describe(ch chan<- *prometheus.Desc) {
	for _, vv := range md.prometheusCounter {
		ch <- vv
	}
}

// Collect returns the metrics with values
func (md * MetricsData) Collect(ch chan<- prometheus.Metric) {
	for keyName, vv := range md.prometheusCounter {
		// ch <- prometheus.MustNewConstMetric(c.TotalRequestsCount, prometheus.CounterValue, float64(status.StatStorage.GetTotalCount()))
		ch <- prometheus.MustNewConstMetric(vv, prometheus.CounterValue, float64(md.Data[keyName]))
	}
}
